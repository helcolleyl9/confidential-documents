# Confidential Documents

**Next-Generation Encrypted Document Storage on the Blockchain**

Confidential Documents revolutionizes how sensitive documents are stored and managed in a decentralized environment. Built on Zama's Fully Homomorphic Encryption Virtual Machine (FHEVM), this platform enables truly private document reference storage on Ethereum while maintaining complete user sovereignty. Your documents remain encrypted throughout the entire blockchain lifecycle, accessible only by you, yet fully auditable and verifiable on-chain.

[![License](https://img.shields.io/badge/License-BSD_3--Clause--Clear-blue.svg)](LICENSE)
[![Solidity](https://img.shields.io/badge/Solidity-0.8.24-orange.svg)](https://soliditylang.org/)
[![Hardhat](https://img.shields.io/badge/Built%20with-Hardhat-yellow.svg)](https://hardhat.org/)

---

## üìñ Table of Contents

- [Overview](#overview)
- [Key Features](#key-features)
- [Problem Statement](#problem-statement)
- [Solution Architecture](#solution-architecture)
- [Technology Stack](#technology-stack)
- [Smart Contract Details](#smart-contract-details)
- [Frontend Application](#frontend-application)
- [How It Works](#how-it-works)
- [Project Structure](#project-structure)
- [Installation](#installation)
- [Usage](#usage)
- [Deployment](#deployment)
- [Security Considerations](#security-considerations)
- [Advantages](#advantages)
- [Future Roadmap](#future-roadmap)
- [Contributing](#contributing)
- [License](#license)

---

## üéØ Overview

Confidential Documents represents a paradigm shift in secure document management, combining the immutability of blockchain with state-of-the-art cryptographic privacy. Users upload documents to the InterPlanetary File System (IPFS), generate content identifiers, and store encrypted references on Ethereum using Fully Homomorphic Encryption. This architecture guarantees that document references can only be decrypted by their rightful owners, while leveraging blockchain's decentralization and tamper-proof properties.

### Why This Matters

- **üîí Unbreakable Privacy**: FHE encryption ensures your document references remain confidential even during smart contract execution
- **‚õìÔ∏è Trustless Architecture**: All encrypted data resides directly on-chain, eliminating reliance on third-party servers
- **üë§ Cryptographic Ownership**: You alone hold the keys to decrypt your document references
- **üåê Zero Backend**: Fully decentralized architecture with no central point of failure
- **üì¶ Distributed Storage**: Leverages IPFS for resilient, distributed document hosting
- **‚úÖ Battle-Tested**: Successfully deployed on Ethereum Sepolia with comprehensive functionality

---

## ‚ú® Core Capabilities

### 1. **Cryptographically Secure Reference Storage**
- Convert IPFS content identifiers into encrypted EVM addresses for on-chain storage
- Each document reference is securely split into two encrypted addresses
- Encrypted data remains invisible to everyone except the document owner

### 2. **Streamlined User Experience**
- Contemporary React-based interface with fluid animations
- Seamless wallet integration via RainbowKit supporting all major wallets
- Real-time transaction tracking and status notifications
- Intuitive document upload and management workflows

### 3. **Advanced Privacy Infrastructure**
- Zama's FHEVM powers on-chain encryption operations
- Cryptographic proofs guarantee data authenticity and integrity
- Client-side encryption ensures data is protected before blockchain submission
- EIP-712 signatures enable secure, authorized decryption requests

### 4. **Decentralized Design Philosophy**
- Serverless architecture eliminates single points of failure
- Direct blockchain communication through Web3 libraries
- IPFS integration for distributed, resilient document storage
- Smart contract-based access management and permissions

### 5. **Comprehensive Document Management**
- Submit documents with personalized naming conventions
- View encrypted document collections organized by wallet address
- Reveal IPFS hashes through a secure, multi-step decryption process
- Comprehensive timestamp tracking for all document submissions

---

## üîç Challenges Addressed

Traditional document storage solutions encounter significant obstacles:

### Privacy Vulnerabilities
- **Centralized Authority**: Service providers maintain access to all stored data
- **Breach Susceptibility**: Single points of failure expose entire user datasets
- **Surveillance Concerns**: Unauthorized third-party access remains a constant threat
- **Ownership Gaps**: Users lack genuine ownership of their stored information

### Blockchain Constraints
- **Transparency Overhead**: Conventional blockchain transactions expose details to all network participants
- **Privacy Trade-offs**: Decentralization typically compromises user privacy
- **Metadata Leakage**: Even encrypted data can reveal sensitive information through metadata analysis

### Current Solution Gaps
- **Incomplete Encryption**: Traditional encryption on public chains still exposes access patterns
- **Hybrid Architectures**: Off-chain components reintroduce trust dependencies
- **Partial Protection**: Most solutions encrypt only subsets of sensitive data

---

## üí° Architectural Approach

Confidential Documents tackles these challenges through a comprehensive privacy-first methodology:

### Fully Homomorphic Encryption (FHE)
- **Persistent On-Chain Privacy**: Data remains encrypted throughout smart contract execution cycles
- **Zero-Knowledge Computations**: Smart contracts process encrypted data without ever decrypting it
- **Exclusive Owner Access**: Only data owners possess the capability to decrypt their information

### Cryptographic Innovations
1. **IPFS CID Transformation**: Document hashes are deterministically converted into two EVM addresses
2. **FHE Encryption Layer**: Zama's relayer SDK encrypts addresses using state-of-the-art FHE primitives
3. **Proof Generation**: Cryptographic proofs validate encrypted inputs before contract acceptance
4. **Granular Access Control**: Smart contracts enforce fine-grained permissions for encrypted data access

### Decentralized Storage Model
```
User Document ‚Üí SHA-256 Hash ‚Üí IPFS CID ‚Üí Split into 2 Addresses ‚Üí FHE Encryption ‚Üí Blockchain Storage
                                                                                              ‚Üì
User Retrieval ‚Üê IPFS CID Reconstruction ‚Üê Address Decryption ‚Üê EIP-712 Signature ‚Üê User Request
```

---

## üõ† Technology Stack

### Smart Contract Layer
- **Solidity 0.8.24**: Smart contract development
- **FHEVM Library**: Fully Homomorphic Encryption primitives
- **Hardhat**: Development framework and testing environment
- **Hardhat Deploy**: Deployment management and artifact tracking
- **TypeChain**: Type-safe contract interactions

### Frontend Layer
- **React 19**: Modern UI library with hooks
- **TypeScript**: Type-safe JavaScript development
- **Vite**: Fast build tool and development server
- **Wagmi**: React hooks for Ethereum
- **Viem**: TypeScript EVM library for contract reads
- **Ethers.js v6**: Ethereum library for contract writes
- **RainbowKit**: Wallet connection UI

### Cryptography & Privacy
- **@fhevm/solidity**: Zama's FHE Solidity library
- **@zama-fhe/relayer-sdk**: Client-side encryption SDK
- **EIP-712**: Structured data signing for decryption authorization

### Infrastructure
- **Ethereum Sepolia**: Target blockchain network
- **Infura**: RPC provider for network access
- **IPFS**: Distributed file storage protocol

---

## üìú Smart Contract Details

### Confidential Documents Contract

**Location**: `contracts/ZamaFile.sol`

The `ZamaFile` contract serves as the foundational component managing encrypted document references on-chain.

#### Contract Structure

```solidity
struct Record {
    string name;        // Plaintext filename (user-provided)
    uint256 timestamp;  // Unix timestamp of submission
    eaddress addr1;     // First encrypted address (from IPFS CID)
    eaddress addr2;     // Second encrypted address (from IPFS CID)
}
```

#### Key Functions

**submitRecord**
```solidity
function submitRecord(
    string calldata _name,
    externalEaddress _addr1,
    externalEaddress _addr2,
    bytes calldata inputProof
) external
```
- Stores a new encrypted file record
- Validates encrypted inputs via proof verification
- Sets up access control list (ACL) for owner and contract
- Emits `RecordSubmitted` event

**getRecordCount**
```solidity
function getRecordCount(address user) external view returns (uint256)
```
- Returns the total number of records for a specific user
- Used for pagination and list rendering

**getRecord**
```solidity
function getRecord(address user, uint256 index)
    external view
    returns (string memory name, uint256 timestamp, eaddress addr1, eaddress addr2)
```
- Retrieves a specific record by index
- Returns both plaintext metadata and encrypted addresses
- Encrypted addresses can only be decrypted by the owner

**getRecordNames**
```solidity
function getRecordNames(address user) external view returns (string[] memory)
```
- Convenience function to fetch all filenames for a user
- Useful for quick list previews

#### Security Features

1. **Proof Verification**: All encrypted inputs must include valid cryptographic proofs
2. **Access Control**: ACL automatically configured for owner and contract
3. **Per-User Storage**: Records are isolated by wallet address
4. **Immutable Records**: Once submitted, records cannot be modified
5. **Event Logging**: All submissions emit events for off-chain tracking

---

## üé® Frontend Application

### Architecture

The frontend is architected using modern React principles, emphasizing type safety, modular design, and exceptional user experience.

**Location**: `home/src/`

### Core Components

#### 1. **App.tsx** (Root Component)
- Sets up Web3 providers (Wagmi, RainbowKit, TanStack Query)
- Configures global application state
- Manages wallet connection lifecycle

#### 2. **FileApp.tsx** (Main Container)
- Tab navigation between Submit and List views
- Responsive layout and styling
- State management for active view

#### 3. **FileSubmission.tsx** (Upload Interface)
- File selection and upload handling
- IPFS CID generation via SHA-256
- FHE encryption of addresses
- Transaction submission and confirmation
- Real-time status feedback

#### 4. **FileList.tsx** (File Management)
- Fetches user's encrypted records from blockchain
- Displays file list with metadata
- Handles secure decryption via EIP-712 signatures
- Reveals IPFS CIDs on demand

#### 5. **Header.tsx** (Navigation Bar)
- Displays application branding
- RainbowKit wallet connection button
- Responsive design

### Custom Hooks

#### useZamaInstance
```typescript
export function useZamaInstance()
```
- Initializes Zama FHE instance
- Manages instance lifecycle and errors
- Provides encryption/decryption capabilities

#### useEthersSigner
```typescript
export function useEthersSigner()
```
- Converts Wagmi client to Ethers.js signer
- Enables write operations to smart contracts
- Handles provider switching

### Utility Functions

#### IPFS Conversion (`utils/ipfs.ts`)

**mockIPFSUpload**
```typescript
async function mockIPFSUpload(file: File): Promise<string>
```
- Computes SHA-256 hash of file
- Generates CIDv0 format identifier
- Returns base58-encoded CID

**ipfsToAddresses**
```typescript
function ipfsToAddresses(cid: string): { addr1: string; addr2: string }
```
- Decodes base58 CID to bytes
- Splits multihash into two 20-byte addresses
- Returns EVM-compatible address pair

**addressesToIpfs**
```typescript
function addressesToIpfs(addr1: string, addr2: string): string
```
- Reconstructs multihash from two addresses
- Encodes back to base58 CID
- Enables file retrieval from IPFS

### Styling

**Modern Design System** (`styles/FileApp.css`, `index.css`)
- CSS custom properties for theming
- Glassmorphism effects and gradients
- Smooth animations and transitions
- Responsive layouts for all screen sizes
- Dark mode optimized

---

## ‚öôÔ∏è How It Works

### Complete User Flow

#### 1. **File Submission Process**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User       ‚îÇ
‚îÇ  Selects    ‚îÇ
‚îÇ  File       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Compute SHA-256    ‚îÇ
‚îÇ  Generate IPFS CID  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Convert CID to 2         ‚îÇ
‚îÇ  EVM Addresses            ‚îÇ
‚îÇ  (20 bytes each)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Initialize Zama Instance ‚îÇ
‚îÇ  Create Encrypted Input   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Encrypt Both Addresses   ‚îÇ
‚îÇ  with FHE                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Generate Cryptographic   ‚îÇ
‚îÇ  Proof for Validation     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Submit Transaction to    ‚îÇ
‚îÇ  Smart Contract           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Smart Contract Validates ‚îÇ
‚îÇ  Proof & Stores Data      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 2. **File Retrieval Process**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User       ‚îÇ
‚îÇ  Views List ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Fetch Record Count ‚îÇ
‚îÇ  from Smart Contract‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Query Each Record        ‚îÇ
‚îÇ  (Name, Timestamp, etc.)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Display List with        ‚îÇ
‚îÇ  Encrypted Handles        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº (User clicks "Reveal")
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Generate Keypair         ‚îÇ
‚îÇ  Create EIP-712 Message   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Signs EIP-712       ‚îÇ
‚îÇ  Authorization Request    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Call Zama Relayer        ‚îÇ
‚îÇ  Decrypt Addresses        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Reconstruct IPFS CID     ‚îÇ
‚îÇ  from Decrypted Addresses ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Display IPFS Hash        ‚îÇ
‚îÇ  User Can Access File     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Technical Deep Dive

#### Encryption Process
1. **Input Preparation**: User's file generates an IPFS CID
2. **Address Conversion**: CID is split into two 20-byte EVM addresses
3. **Encryption Setup**: Zama instance creates encrypted input object
4. **FHE Encryption**: Each address is encrypted using FHE primitives
5. **Proof Generation**: Relayer SDK generates zero-knowledge proof
6. **Submission**: Encrypted handles and proof sent to smart contract

#### Decryption Process
1. **Authorization**: User generates temporary keypair
2. **EIP-712 Signing**: User signs structured authorization message
3. **Relayer Request**: Frontend calls Zama relayer with signature
4. **Server-Side Decryption**: Relayer validates and decrypts data
5. **Client Reconstruction**: Frontend converts addresses back to CID

---

## üìÅ Project Structure

```
confidential-documents/
‚îú‚îÄ‚îÄ contracts/                 # Smart contract source files
‚îÇ   ‚îú‚îÄ‚îÄ FHECounter.sol        # Example FHE counter contract
‚îÇ   ‚îî‚îÄ‚îÄ ZamaFile.sol          # Main file storage contract
‚îÇ
‚îú‚îÄ‚îÄ deploy/                    # Deployment scripts
‚îÇ   ‚îú‚îÄ‚îÄ 01_zamafile.ts        # ZamaFile contract deployment
‚îÇ   ‚îî‚îÄ‚îÄ deploy.ts             # General deployment utilities
‚îÇ
‚îú‚îÄ‚îÄ test/                      # Smart contract tests
‚îÇ   ‚îú‚îÄ‚îÄ FHECounter.ts         # Counter contract tests
‚îÇ   ‚îî‚îÄ‚îÄ FHECounterSepolia.ts  # Sepolia-specific tests
‚îÇ
‚îú‚îÄ‚îÄ tasks/                     # Hardhat custom tasks
‚îÇ   ‚îú‚îÄ‚îÄ accounts.ts           # Account management tasks
‚îÇ   ‚îî‚îÄ‚îÄ FHECounter.ts         # Counter interaction tasks
‚îÇ
‚îú‚îÄ‚îÄ home/                      # Frontend application
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/       # React components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FileApp.tsx   # Main container
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FileSubmission.tsx # Upload interface
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FileList.tsx  # File management
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Header.tsx    # Navigation bar
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useZamaInstance.ts # FHE instance hook
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useEthersSigner.ts # Ethers signer hook
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/           # Configuration files
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wagmi.ts      # Web3 configuration
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contracts.ts  # Contract ABI and address
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/            # Utility functions
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ipfs.ts       # IPFS conversion utilities
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ styles/           # CSS stylesheets
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FileApp.css   # Component styles
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx           # Root component
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.tsx          # Application entry point
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ index.html            # HTML template
‚îÇ   ‚îú‚îÄ‚îÄ package.json          # Frontend dependencies
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts        # Vite configuration
‚îÇ
‚îú‚îÄ‚îÄ deployments/              # Deployment artifacts
‚îÇ   ‚îî‚îÄ‚îÄ sepolia/              # Sepolia network deployments
‚îÇ       ‚îî‚îÄ‚îÄ ZamaFile.json     # Contract ABI and address
‚îÇ
‚îú‚îÄ‚îÄ hardhat.config.ts         # Hardhat configuration
‚îú‚îÄ‚îÄ package.json              # Root dependencies
‚îú‚îÄ‚îÄ tsconfig.json             # TypeScript configuration
‚îú‚îÄ‚îÄ .env                      # Environment variables (private)
‚îî‚îÄ‚îÄ README.md                 # This file
```

---

## üöÄ Installation

### Prerequisites

- **Node.js**: Version 20 or higher
- **npm**: Version 7.0.0 or higher
- **MetaMask** or compatible Web3 wallet
- **Sepolia ETH**: For testnet transactions

### Step 1: Install Dependencies

```bash
# Install root dependencies (Hardhat, contracts)
npm install

# Install frontend dependencies
cd home
npm install
cd ..
```

### Step 3: Configure Environment Variables

Create a `.env` file in the root directory:

```bash
# Wallet configuration
MNEMONIC="your twelve word mnemonic phrase here"
PRIVATE_KEY="your_private_key_without_0x_prefix"

# RPC provider
INFURA_API_KEY="your_infura_api_key"

# Optional: Contract verification
ETHERSCAN_API_KEY="your_etherscan_api_key"
```

**Security Warning**: Keep your `.env` file secure and never share it publicly!

### Step 4: Configure Hardhat Variables (Alternative)

```bash
# Set mnemonic securely
npx hardhat vars set MNEMONIC

# Set Infura API key
npx hardhat vars set INFURA_API_KEY

# Optional: Set Etherscan API key
npx hardhat vars set ETHERSCAN_API_KEY
```

---

## üî® Build Commands

### Smart Contract Build Commands

#### Compile Contracts

```bash
# Compile all smart contracts
npm run compile

# This will:
# - Compile Solidity contracts
# - Generate TypeScript types via TypeChain
# - Output artifacts to ./artifacts
```

#### Clean Build Artifacts

```bash
# Remove all build artifacts and generated files
npm run clean

# This removes:
# - ./artifacts (compiled contracts)
# - ./cache (Hardhat cache)
# - ./coverage (test coverage reports)
# - ./types (TypeChain types)
# - ./dist (frontend build)
```

#### Generate TypeScript Types

```bash
# Generate TypeScript types from contracts
npm run typechain

# Types are generated to ./types directory
```

### Frontend Build Commands

#### Development Build

```bash
# Navigate to frontend directory
cd home

# Start development server with hot reload
npm run dev

# Server runs on http://localhost:5173
```

#### Production Build

```bash
# Navigate to frontend directory
cd home

# Build for production
npm run build

# This will:
# - Compile TypeScript
# - Bundle with Vite
# - Optimize assets
# - Output to ./dist directory
```

**Build Output:**
- All production files are generated in the `dist/` directory
- Static assets are optimized and minified
- Ready for deployment to hosting providers (Vercel, Netlify, etc.)

**Note:** During build, you may see warnings about `/*#__PURE__*/` comments from third-party dependencies (ox library). These are harmless and Vite will automatically handle them. The build will complete successfully.

#### Type Checking (Frontend)

```bash
# Type check TypeScript files
npm run build:ts

# Or from frontend directory:
cd home
npm run build:ts
```

### Full Build Process

#### Complete Build from Scratch

```bash
# 1. Clean previous builds
npm run clean

# 2. Install dependencies (if needed)
npm install
cd home && npm install && cd ..

# 3. Compile contracts
npm run compile

# 4. Build frontend
cd home
npm run build
cd ..

# 5. Verify build output
# - Check ./artifacts for contract artifacts
# - Check ./dist for frontend build
```

### Build Verification

```bash
# Run tests after building
npm run test

# Check for linting errors
npm run lint

# Run test coverage
npm run coverage
```

---

## üìñ Usage

### Local Development

#### 1. Start Local FHEVM Node

```bash
# Terminal 1: Start local Hardhat node with FHEVM support
npx hardhat node
```

#### 2. Compile Contracts

```bash
# Terminal 2: Compile smart contracts
npm run compile
```

#### 3. Run Tests

```bash
# Run all tests
npm run test

# Run specific test file
npx hardhat test test/FHECounter.ts
```

#### 4. Deploy Contracts Locally

```bash
# Deploy to local node
npx hardhat deploy --network localhost
```

#### 5. Start Frontend Development Server

```bash
# Terminal 3: Navigate to frontend and start dev server
cd home
npm run dev
```

Open `http://localhost:5173` in your browser.

### Testnet Deployment (Sepolia)

#### 1. Deploy Smart Contract

```bash
# Deploy Confidential Documents contract to Sepolia
npx hardhat deploy --network sepolia
```

Output will show:
```
Deploying Confidential Documents...
Confidential Documents contract: 0x1234567890abcdef1234567890abcdef12345678
```

#### 2. Verify Contract on Etherscan

```bash
# Verify deployed contract
npx hardhat verify --network sepolia <CONTRACT_ADDRESS>
```

#### 3. Update Frontend Configuration

Edit `home/src/config/contracts.ts`:

```typescript
export const CONTRACT_ADDRESS = '0x1234567890abcdef1234567890abcdef12345678';
```

Copy ABI from `deployments/sepolia/ZamaFile.json` to the same file.

#### 4. Update Wagmi Configuration

Edit `home/src/config/wagmi.ts`:

```typescript
export const config = getDefaultConfig({
  appName: 'Confidential Documents',
  projectId: 'YOUR_WALLETCONNECT_PROJECT_ID', // Get from https://cloud.walletconnect.com
  chains: [sepolia],
  ssr: false,
});
```

#### 5. Build Frontend for Production

```bash
cd home
npm run build
```

Deploy the `dist/` folder to your hosting provider (Vercel, Netlify, etc.).

### Interacting with the Application

#### Submit a File

1. **Connect Wallet**: Click "Connect Wallet" in the header
2. **Select File**: Choose a file from your computer
3. **Upload to IPFS**: Click "Upload IPFS" to generate hash
4. **Submit to Blockchain**: Click "Submit to Blockchain"
5. **Confirm Transaction**: Approve the transaction in your wallet
6. **Wait for Confirmation**: Transaction will be mined in ~15 seconds

#### View Your Files

1. **Switch to "My Files" Tab**
2. **View File List**: See all your submitted files
3. **Reveal IPFS Hash**: Click "Reveal IPFS Hash" on any file
4. **Sign Authorization**: Sign the EIP-712 message
5. **View Decrypted Hash**: IPFS CID will be displayed

---

## üîê Security Considerations

### Smart Contract Security

1. **Access Control**: Only file owners can decrypt their data
2. **Proof Verification**: All encrypted inputs validated via cryptographic proofs
3. **Immutability**: Records cannot be modified after submission
4. **Event Logging**: All actions logged for transparency and auditing

### Frontend Security

1. **Client-Side Encryption**: All encryption happens in the browser
2. **Private Key Protection**: Private keys never leave the user's wallet
3. **Secure Communication**: HTTPS required for production deployment
4. **Input Validation**: All user inputs sanitized and validated

### Cryptographic Security

1. **FHE Guarantees**: Encrypted data never decrypted on-chain
2. **Zero-Knowledge Proofs**: Proof-based validation without revealing data
3. **EIP-712 Signatures**: Structured signing prevents replay attacks
4. **Temporal Validation**: Decryption authorizations time-limited

### Operational Security

1. **Environment Variables**: Sensitive data stored securely
2. **Key Management**: Private keys managed via hardware wallets recommended
3. **Network Security**: RPC endpoints should use secure connections
4. **Dependency Auditing**: Regular security audits of dependencies

### Known Limitations

1. **Filename Privacy**: Filenames are stored in plaintext (by design for UX)
2. **Metadata Leakage**: Transaction timestamps and addresses are public
3. **IPFS Availability**: Files must be pinned to remain accessible
4. **Gas Costs**: FHE operations more expensive than standard transactions

---

## üåü Advantages

### For Users

1. **Complete Privacy**: Only you can access your file references
2. **True Ownership**: Your data lives on the blockchain, not someone else's server
3. **Censorship Resistant**: No central authority can block or delete your files
4. **Portable Identity**: Access your files from any device with your wallet
5. **Transparent Security**: Open-source code auditable by anyone

### For Developers

1. **Simple Integration**: Easy-to-use SDK and clear documentation
2. **Type Safety**: Full TypeScript support across the stack
3. **Modern Stack**: Built with latest tools and best practices
4. **Extensible**: Clean architecture easy to customize and extend
5. **Well-Tested**: Comprehensive test suite ensures reliability

### Technical Advantages

1. **On-Chain Privacy**: First-class support for encrypted data processing
2. **Gas Efficient**: Optimized contract code minimizes transaction costs
3. **Scalable Architecture**: Modular design supports future enhancements
4. **Cross-Platform**: Works on desktop and mobile browsers
5. **No Backend**: Fully decentralized with no server dependencies

### Business Advantages

1. **Cost Effective**: No infrastructure costs for backend services
2. **Regulatory Friendly**: Privacy-by-design architecture
3. **Vendor Independence**: Not locked into any cloud provider
4. **Future-Proof**: Built on emerging Web3 standards
5. **Competitive Edge**: Cutting-edge privacy technology

---

## üó∫ Future Roadmap

### Phase 1: Core Enhancements (Q2 2025)

- [ ] **File Sharing**: Encrypted sharing with other wallet addresses
- [ ] **Access Control Lists**: Granular permission management
- [ ] **Batch Operations**: Submit multiple files in one transaction
- [ ] **Metadata Encryption**: Optional encryption for filenames
- [ ] **Mobile Optimization**: Responsive design improvements

### Phase 2: Advanced Features (Q3 2025)

- [ ] **File Versioning**: Track file history and updates
- [ ] **Folder Structure**: Organize files into directories
- [ ] **Search Functionality**: Encrypted search capabilities
- [ ] **Expiration Dates**: Time-limited file access
- [ ] **Multi-Chain Support**: Deploy to Polygon, Arbitrum, etc.

### Phase 3: Enterprise Features (Q4 2025)

- [ ] **Organization Accounts**: Multi-user team workspaces
- [ ] **Role-Based Access**: Admin, editor, viewer roles
- [ ] **Audit Logs**: Comprehensive activity tracking
- [ ] **Compliance Tools**: GDPR, HIPAA compliance features
- [ ] **API Gateway**: Programmatic access for integrations

### Phase 4: Ecosystem Growth (2026)

- [ ] **IPFS Pinning Service**: Automatic file pinning integration
- [ ] **NFT Integration**: Mint files as NFTs with encrypted metadata
- [ ] **Cross-Chain Bridge**: Transfer file references between chains
- [ ] **Decentralized Identity**: Integration with ENS, Lens, etc.
- [ ] **Mobile App**: Native iOS and Android applications

### Community & Research

- [ ] **Bug Bounty Program**: Reward security researchers
- [ ] **Developer Grants**: Fund ecosystem projects
- [ ] **Academic Partnerships**: Research collaboration
- [ ] **Documentation Portal**: Comprehensive guides and tutorials
- [ ] **Integration Marketplace**: Third-party extensions

### Infrastructure Improvements

- [ ] **Gas Optimization**: Further reduce transaction costs
- [ ] **Batch Decryption**: Decrypt multiple files at once
- [ ] **Offline Mode**: Local caching and sync capabilities
- [ ] **Performance Monitoring**: Analytics and metrics dashboard
- [ ] **Automated Testing**: CI/CD pipeline enhancements

---

## ü§ù Contributing

We welcome contributions from the community! Here's how you can help:

### Ways to Contribute

1. **Report Bugs**: Report bugs you encounter
2. **Suggest Features**: Share your ideas for improvements
3. **Submit Improvements**: Fix bugs or implement new features
4. **Improve Documentation**: Help make docs clearer and more comprehensive
5. **Write Tests**: Increase test coverage
6. **Review Code**: Provide feedback on code changes

### Development Process

1. **Set Up Your Environment**
   - Follow the Installation instructions
   - Ensure all dependencies are installed

2. **Make Your Changes**
   - Write clean, documented code
   - Follow existing code style
   - Add tests for new functionality

3. **Test Your Changes**
   ```bash
   npm run test
   npm run lint
   ```

### Code Style Guidelines

- **Solidity**: Follow official Solidity style guide
- **TypeScript**: Use ESLint configuration provided
- **Comments**: Write clear, concise comments in English
- **Naming**: Use descriptive variable and function names
- **Testing**: Aim for >80% code coverage

### Community Guidelines

- Be respectful and inclusive
- Provide constructive feedback
- Help others learn and grow

---

## üìÑ License

This project is licensed under the **BSD-3-Clause-Clear License**.

```
BSD 3-Clause Clear License

Copyright (c) 2024, Confidential Documents Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted (subject to the limitations in the disclaimer
below) provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY
THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

---

## üÜò Support

### Getting Help

- **Zama Documentation**: [FHEVM Docs](https://docs.zama.ai/fhevm)
- **Zama Community**: [Join Discord](https://discord.gg/zama)

### Useful Resources

- [FHEVM Documentation](https://docs.zama.ai/fhevm)
- [Hardhat Documentation](https://hardhat.org/docs)
- [React Documentation](https://react.dev)
- [Wagmi Documentation](https://wagmi.sh)
- [Viem Documentation](https://viem.sh)
- [RainbowKit Documentation](https://rainbowkit.com)

---

## üôè Acknowledgments

Built with amazing open-source technologies:

- **Zama**: For pioneering FHE on Ethereum
- **Hardhat**: For excellent smart contract development tools
- **React Team**: For the powerful UI library
- **Wagmi Team**: For simplifying Web3 integration
- **RainbowKit Team**: For beautiful wallet connection UX
- **IPFS Community**: For decentralized storage innovation

---

## üìä Project Status

- **Version**: 1.0.0
- **Status**: Production Ready ‚úÖ
- **Network**: Ethereum Sepolia Testnet
- **Last Updated**: September 2024
- **Maintained**: Actively maintained

---

## üéØ Use Cases

### Personal Use
- Secure document backup with privacy
- Private photo storage references
- Encrypted diary or journal entries
- Medical records management

### Business Applications
- Confidential contract storage
- Secure credential management
- Privacy-compliant data archival
- Encrypted audit trails

### Development & Research
- Decentralized application building blocks
- Privacy-preserving storage research
- FHE technology demonstration
- Blockchain education and training

---

**Built with ‚ù§Ô∏è using Fully Homomorphic Encryption**

---

*Disclaimer: This is experimental technology deployed on testnet. Use at your own risk. Always perform due diligence before using in production environments.*